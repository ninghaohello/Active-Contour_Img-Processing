//
//  seed.cpp
//
//  Created by Ninghao Liu on 3/19/10.
//

#include "ActContour.h"

#include <iostream>
#include <opencv/cv.h>
#include <opencv/highgui.h>
#include <opencv2\core\core.hpp>

using namespace std;  
using namespace cv;

void myMouseCallBack(int event, int x, int y, int flags, void * param);
void GetInteractiveCurve(Mat & org_image, int* xy12);
CvRect box;				//rectangles are generated by this
bool drawing_box = false; 
void draw_box(IplImage * img, CvRect rect);

int main()
{
	Mat org_image;
	int xy12[4];
	string fileName= "dolphin.jpg";
	org_image = imread(fileName, CV_LOAD_IMAGE_COLOR);

	if(!org_image.data)
	{
		printf("No image data\n");
		return -1;
	}

	//Initial curve determined in an interactive way
	GetInteractiveCurve(org_image, xy12);
	cout << "corrdinates: " << xy12[0] << " " << xy12[1] << " " <<xy12[2] << " " <<xy12[3] << endl;

	//Gray image for active contour model
	Mat image;
	cvtColor(org_image, image, CV_BGR2GRAY );
	GaussianBlur(image,image,Size(3,3),0,0);
	imwrite("Gray_Image.jpg", image );
	
	ActiveContour ac = ActiveContour(image);
	//ac.SimpleInitialization();
	ac.InteractiveInitialization(xy12);
	ac.ShowLevelSetMat();
	ac.ChanVeseSeed();
	ac.SetShow();
	ac.Reinitialization();
	int count = 0;
	while(true)
	{
		ac.UpdateLevelSet();
		if(ac.TouchMine())
		{
			ac.ResetInBandMat();
			ac.ResetTraveMat();
			ac.ResetParentMat();
			ac.FindCurvePoints1(true);
			ac.ChanVeseSeed();
			ac.Reinitialization();
		}
		else
		{
			ac.ResetParentMat();
			ac.ResetTraveMat();
			ac.FindCurvePoints1(false);				
			ac.ChanVeseSeed();
			ac.ExtendExternalField();
		}
		if(count%1 ==0)
		{
			//ac.ShowLevelSetMat();		//select curve points from negative elements in levelSetMat may work
			//ac.ShowCurve();
			cout << "energy: " << ac.ComputeEnergy() << endl;
		}
		if(count%15 == 0)
			ac.ShowCurve();
		count ++;
	}

	return 0;
}

void draw_box(IplImage * img, CvRect rect) 
{  
    cvRectangle(img, cvPoint(box.x, box.y), cvPoint(box.x + box.width, box.y + box.height), cvScalar(0x00, 0xff, 0xff));
}

void GetInteractiveCurve(Mat & org_image, int* xy12)
{
	Mat dst;
	float alpha = 0.7;
	float beta = 1 - alpha;

    IplImage * image = cvCreateImage(org_image.size(), IPL_DEPTH_8U, 3);  
    cvZero(image); 
    IplImage * temp = cvCloneImage(image);		//reallocate new memory 
    cvNamedWindow("Box Example");
    cvSetMouseCallback("Box Example", myMouseCallBack, (void*)image);		//core function, give this window certain mechanism

    while(1)  
    {
        cvCopyImage(image, temp);				//just copy, will not reallocate new memory
        if(drawing_box)
		{
            xy12[1] = box.x; xy12[0]= box.y; xy12[3] = box.x + box.width; xy12[2] = box.y + box.height;
			draw_box(temp,box);
		}

		addWeighted(org_image, alpha, Mat(temp), beta, 0.0, dst);
        imshow("Box Example", dst);
		imwrite("rectagle.jpg", Mat(temp));
        waitKey(30);
		if(cvWaitKey(15) == 27)
			break;
    }  

    cvReleaseImage(&image);
    cvReleaseImage(&temp);
    cvDestroyWindow("Box Example");
}


void myMouseCallBack(int event, int x, int y, int flags, void * param)  
{  
    IplImage * image = (IplImage*)param;  
  
    switch(event)  
    {  
    case CV_EVENT_MOUSEMOVE:  
        {  
            if(drawing_box)  
            {  
                box.width = x - box.x;  
                box.height = y - box.y;  
            }  
        }  
        break;  
    case CV_EVENT_LBUTTONDOWN:  
        {  
            drawing_box = true;  
            box = cvRect(x,y,0,0);		//initialize a rectangle
        }  
        break;  
    case CV_EVENT_LBUTTONUP:  
        {  
            drawing_box = false;  
            if(box.width < 0)  
            {  
                box.x += box.width;  
                box.width *= -1;  
            }  
            if(box.height < 0)  
            {  
                box.y += box.height;  
                box.height *= -1;  
            }  
            draw_box(image,box);  
        }  
        break;  
    }  
  
}
